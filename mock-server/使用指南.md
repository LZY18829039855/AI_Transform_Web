# Mock Server 使用指南

## 一、如何启动 Mock Server

### 1. 安装依赖
```bash
cd mock-server
npm install
```

### 2. 启动服务
```bash
npm run dev
```

默认端口为 `3800`，可通过环境变量 `MOCK_SERVER_PORT` 自定义端口。

### 3. 验证服务
访问 `http://localhost:3800/health`，应该返回：
```json
{
  "code": 200,
  "message": "mock server works",
  "data": { "status": "ok" },
  "timestamp": 1234567890
}
```

## 二、如何配置前端使用 Mock Server

### 方法 1：通过环境变量（推荐）

在前端项目根目录创建 `.env.local` 文件（或修改现有环境变量文件）：

```env
VITE_API_BASE_URL=http://localhost:3800
```

然后重启前端开发服务器。

### 方法 2：修改前端代码

如果前端代码中硬编码了 API 基础路径，需要修改为 mock-server 的地址。

查看 `ai-dashboard/src/utils/request.ts`，当前配置为：
```typescript
export const request = new Request('/ai_transform_webapi')
```

如果需要使用 mock-server，可以临时修改为：
```typescript
export const request = new Request('http://localhost:3800')
```

## 三、如何添加新的 Mock 接口

### 步骤 1：准备接口信息

在添加新的 mock 接口之前，需要提供以下信息：

#### 必需信息：
1. **接口路径**：完整的 API 路径
   - 例如：`/expert-cert-statistics/cadre-qualified-details`

2. **HTTP 方法**：GET、POST、PUT、DELETE 等

3. **请求参数**：
   - 查询参数（Query Parameters）
   - 路径参数（Path Parameters）
   - 请求体（Request Body，如果是 POST/PUT）

4. **响应数据结构**：
   - 完整的响应对象结构
   - 字段类型和说明
   - 示例数据

#### 示例：添加 `/cadre-qualified-details` 接口

**接口信息：**
- **路径**：`GET /expert-cert-statistics/cadre-qualified-details`
- **请求参数**：
  - `deptCode` (string, required): 部门编码
  - `aiMaturity` (string, optional): 岗位AI成熟度
  - `jobCategory` (string, optional): 职位类
  - `personType` (integer, required): 人员类型（1-干部）
- **响应结构**：
```typescript
{
  code: 200,
  message: "查询成功",
  data: {
    employeeDetails: [
      {
        name: string,                    // 姓名
        employeeNumber: string,          // 工号
        competenceCategory: string,      // 职位类
        competenceSubcategory: string,   // 职位子类
        firstLevelDept: string,          // 一级部门
        secondLevelDept: string,         // 二级部门
        thirdLevelDept: string,          // 三级部门
        fourthLevelDept: string,         // 四级部门
        fifthLevelDept: string,          // 五级部门
        sixthLevelDept: string,          // 六级部门
        aiMaturity: string,              // 岗位AI成熟度
        miniDeptName: string,            // 最小部门名称
        cadreType: string,               // 干部类型
        competenceFamilyCn: string,      // 能力族
        competenceCategoryCn: string,    // 能力类
        competenceSubcategoryCn: string, // 能力子类
        directionCnName: string,         // 方向中文名称
        competenceRatingCn: string,      // 能力等级中文
        competenceGradeCn: string,       // 能力级别中文
        competenceFrom: string,          // 任职开始时间（ISO 8601格式）
        competenceTo: string             // 任职结束时间（ISO 8601格式）
      }
    ]
  },
  timestamp: number
}
```

### 步骤 2：创建模拟数据文件

在 `src/data/` 目录下创建数据文件，例如 `cadreQualifiedDetails.ts`：

```typescript
import type { EmployeeDetailVO } from '../types'

export const getCadreQualifiedDetails = (
  deptCode: string,
  aiMaturity?: string,
  jobCategory?: string,
  personType: number = 1
): { employeeDetails: EmployeeDetailVO[] } => {
  // 根据参数返回不同的模拟数据
  const mockData: EmployeeDetailVO[] = [
    {
      name: '张三',
      employeeNumber: 'E001234',
      competenceCategory: 'AI',
      competenceSubcategory: '机器学习',
      firstLevelDept: '云核心网运营部',
      secondLevelDept: '亚太运营支撑处',
      thirdLevelDept: '技术支撑组',
      fourthLevelDept: null,
      fifthLevelDept: null,
      sixthLevelDept: null,
      aiMaturity: 'L3',
      miniDeptName: '技术支撑组',
      cadreType: '技术干部',
      competenceFamilyCn: 'AI能力族',
      competenceCategoryCn: 'AI能力类',
      competenceSubcategoryCn: '机器学习子类',
      directionCnName: 'AI方向',
      competenceRatingCn: '高级',
      competenceGradeCn: 'P5',
      competenceFrom: '2023-01-01T00:00:00Z',
      competenceTo: null,
    },
    // 可以添加更多模拟数据
  ]

  // 根据参数过滤数据
  let filtered = mockData
  if (aiMaturity) {
    filtered = filtered.filter(item => item.aiMaturity === aiMaturity)
  }
  if (jobCategory) {
    filtered = filtered.filter(item => item.competenceCategory === jobCategory)
  }

  return { employeeDetails: filtered }
}
```

### 步骤 3：添加 TypeScript 类型定义

在 `src/types.ts` 中添加类型定义：

```typescript
export interface EmployeeDetailVO {
  name: string
  employeeNumber: string
  competenceCategory: string
  competenceSubcategory: string
  firstLevelDept?: string
  secondLevelDept?: string
  thirdLevelDept?: string
  fourthLevelDept?: string
  fifthLevelDept?: string
  sixthLevelDept?: string
  aiMaturity?: string
  miniDeptName?: string
  cadreType?: string
  competenceFamilyCn?: string
  competenceCategoryCn?: string
  competenceSubcategoryCn?: string
  directionCnName?: string
  competenceRatingCn?: string
  competenceGradeCn?: string
  competenceFrom?: string
  competenceTo?: string
}

export interface EmployeeDrillDownResponseVO {
  employeeDetails: EmployeeDetailVO[]
}
```

### 步骤 4：添加路由

在 `src/routes/expertCertStatistics.ts` 中添加路由：

```typescript
import { getCadreQualifiedDetails } from '../data/cadreQualifiedDetails'

router.get('/cadre-qualified-details', (req, res) => {
  const deptCode = typeof req.query.deptCode === 'string' ? req.query.deptCode : '0'
  const aiMaturity = typeof req.query.aiMaturity === 'string' ? req.query.aiMaturity : undefined
  const jobCategory = typeof req.query.jobCategory === 'string' ? req.query.jobCategory : undefined
  const personType = typeof req.query.personType === 'string' 
    ? parseInt(req.query.personType, 10) 
    : 1

  if (!deptCode || deptCode.trim().length === 0) {
    return res.status(400).json(errorResponse('部门ID不能为空', 400))
  }

  if (!personType) {
    return res.status(400).json(errorResponse('人员类型不能为空', 400))
  }

  const data = getCadreQualifiedDetails(deptCode, aiMaturity, jobCategory, personType)
  return res.json(successResponse(data, '查询成功'))
})
```

### 步骤 5：测试接口

启动 mock-server 后，使用浏览器或 Postman 测试：

```
GET http://localhost:3800/ai_transform_webapi/expert-cert-statistics/cadre-qualified-details?deptCode=dept-ict-core-ops&personType=1
```

## 四、调试技巧

### 1. 查看请求日志
Mock-server 使用 `morgan` 中间件记录所有请求，启动后可以在控制台看到：
```
GET /ai_transform_webapi/expert-cert-statistics/cadre-qualified-details?deptCode=0&personType=1 200 15.234 ms
```

### 2. 热重载
使用 `npm run dev` 启动时，修改代码会自动重启服务，无需手动重启。

### 3. 模拟不同场景
可以在数据文件中根据不同的参数返回不同的数据，模拟各种业务场景：
- 空数据场景
- 错误场景
- 大数据量场景
- 边界值场景

### 4. 调试前端代码
在前端代码中设置断点，可以正常调试前端逻辑，mock-server 会返回模拟数据。

## 五、常见问题

### Q1: 前端请求 404？
**A:** 检查：
1. Mock-server 是否已启动
2. 接口路径是否正确（注意路径前缀 `/ai_transform_webapi`）
3. 前端是否配置了正确的 `VITE_API_BASE_URL`

### Q2: 响应格式不匹配？
**A:** 确保 mock-server 返回的格式与后端一致，使用 `successResponse` 和 `errorResponse` 工具函数。

### Q3: CORS 错误？
**A:** Mock-server 已配置 CORS，如果仍有问题，检查前端请求的 Origin 头。

### Q4: 如何模拟错误场景？
**A:** 在路由处理函数中返回错误响应：
```typescript
return res.status(500).json(errorResponse('系统异常，请稍后重试', 500))
```

## 六、需要提供的信息清单

当需要添加新的 mock 接口时，请提供以下信息：

- [ ] **接口路径**：完整的 URL 路径
- [ ] **HTTP 方法**：GET/POST/PUT/DELETE
- [ ] **请求参数**：
  - [ ] 查询参数（名称、类型、是否必需、说明）
  - [ ] 路径参数（如果有）
  - [ ] 请求体结构（如果是 POST/PUT）
- [ ] **响应数据结构**：
  - [ ] 成功响应的完整结构
  - [ ] 字段类型和说明
  - [ ] 示例数据（至少 2-3 条）
- [ ] **错误场景**（可选）：
  - [ ] 可能的错误码和错误信息
- [ ] **业务逻辑**（可选）：
  - [ ] 参数如何影响返回结果
  - [ ] 特殊过滤或排序规则

---

**提示**：可以参考后端 Controller 代码和 Entity 类来获取完整的接口信息。

